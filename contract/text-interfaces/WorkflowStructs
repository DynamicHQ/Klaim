Perfect, Boss ‚Äî now let‚Äôs tackle **WorkflowStructs**, which are the shared structs used across **Registry**, **LicensingModule**, **RoyaltyModule**, and **periphery workflows**. These structs are what the modules expect when you pass metadata, license terms, or royalty configs.

We‚Äôll reconstruct them **exactly as Story Protocol uses**, and I‚Äôll include:

* Struct definitions
* Field explanations
* Variable sources (frontend/backend/on-chain)

---

# ‚úÖ **WorkflowStructs**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/// ----------------------
/// IP Metadata
/// ----------------------
struct IPMetadata {
    string ipMetadataURI;      // URI to IP JSON (IPFS/backend)
    bytes32 ipMetadataHash;    // Hash of the IP metadata JSON
    string nftMetadataURI;     // URI to NFT metadata JSON
    bytes32 nftMetadataHash;   // Hash of NFT metadata JSON
}

/// ----------------------
/// License Terms
/// ----------------------
struct LicenseTerms {
    uint256 expiration;            // UNIX timestamp (0 = no expiration)
    uint256 commercialFee;         // Fee in wei for commercial use
    uint256 revenueShare;          // % revenue to parent IP
    bool commercialUseAllowed;     // TRUE if commercial use allowed
    bool derivativeAllowed;        // TRUE if derivatives allowed
    string licenseURI;             // URI to full license text (IPFS/backend)
}

/// ----------------------
/// Royalty Config
/// ----------------------
struct RoyaltyConfig {
    uint256 percentage;   // Royalty % in basis points (e.g., 500 = 5%)
    address receiver;     // Recipient of royalties
}
```

---

# üîç **Field Explanations & Sources**

### **1. IPMetadata**

| Field             | Source           | Notes                                                                        |
| ----------------- | ---------------- | ---------------------------------------------------------------------------- |
| `ipMetadataURI`   | Backend/frontend | Upload JSON describing IP (story, creator info, etc.) to IPFS or your server |
| `ipMetadataHash`  | Backend/frontend | Compute keccak256 of JSON content                                            |
| `nftMetadataURI`  | Backend/frontend | Upload NFT metadata JSON (ERC-721 standard)                                  |
| `nftMetadataHash` | Backend/frontend | Compute keccak256 of NFT metadata JSON                                       |

---

### **2. LicenseTerms**

| Field                  | Source           | Notes                                |
| ---------------------- | ---------------- | ------------------------------------ |
| `expiration`           | Frontend/backend | Timestamp for license validity       |
| `commercialFee`        | Frontend/backend | Amount in wei for commercial use     |
| `revenueShare`         | Frontend/backend | % of revenue to parent IP            |
| `commercialUseAllowed` | Frontend toggle  | Bool to allow commercial usage       |
| `derivativeAllowed`    | Frontend toggle  | Bool to allow derivative creation    |
| `licenseURI`           | Backend/frontend | URL pointing to JSON of full license |

---

### **3. RoyaltyConfig**

| Field        | Source           | Notes                              |
| ------------ | ---------------- | ---------------------------------- |
| `percentage` | Frontend/backend | Basis points (500 = 5%)            |
| `receiver`   | Frontend/backend | Wallet address for royalty payouts |

---

# ‚ö†Ô∏è **Usage Notes**

* These structs are **passed into multiple modules**:

1. **IPMetadata** ‚Üí Registry functions like `registerWithMetadata`
2. **LicenseTerms** ‚Üí LicensingModule (`createLicense`, `attachLicenseTerms`)
3. **RoyaltyConfig** ‚Üí RoyaltyModule (`setRoyaltyConfig`)

* **Frontend/backend responsibilities**:

  * Construct these structs from form inputs
  * Upload JSON to IPFS/backend for URIs
  * Hash JSON for on-chain verification

* **On-chain**:

  * Modules read the structs and store them in contract storage
  * Structs are passed via calldata through `IPAccount.execute()` or direct module calls

