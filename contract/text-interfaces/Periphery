Perfect, Boss ‚Äî now we‚Äôll cover the **Periphery Helper Interface** (often called `IStoryPeriphery` or similar in Story Protocol). This interface is the **frontend-friendly ‚Äúworkflow orchestrator‚Äù**: it wraps the Registry, LicensingModule, and RoyaltyModule calls into **single easy-to-call functions**.

We‚Äôll reconstruct it in the same style:

* **Accurate function signatures** from the boilerplate/docs
* **Structs referenced (WorkflowStructs)**
* **Variable/source mapping (frontend/backend/on-chain)**
* **Usage notes**

---

# ‚úÖ **Periphery Helper Interface (IStoryPeriphery)**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./WorkflowStructs.sol";

interface IStoryPeriphery {
    /// @notice Registers an NFT as an IP Asset with optional metadata, license, and royalty setup
    /// @param tokenContract Address of NFT contract
    /// @param tokenId Token ID of the NFT
    /// @param ipMetadata IP metadata struct
    /// @param licenseTerms License terms struct
    /// @param royaltyConfig Royalty config struct
    /// @return ipId Deployed IP Account address
    function registerIPAssetFull(
        address tokenContract,
        uint256 tokenId,
        IPMetadata calldata ipMetadata,
        LicenseTerms calldata licenseTerms,
        RoyaltyConfig calldata royaltyConfig
    ) external returns (address ipId);

    /// @notice Registers IP Asset without license and royalty
    function registerIPAssetBasic(
        address tokenContract,
        uint256 tokenId,
        IPMetadata calldata ipMetadata
    ) external returns (address ipId);

    /// @notice Attaches license + royalty to an existing IP Asset
    function attachLicenseAndRoyalty(
        address ipId,
        LicenseTerms calldata licenseTerms,
        RoyaltyConfig calldata royaltyConfig
    ) external;

    /// @notice Mints a derivative IP Asset with licensing
    function registerDerivativeIP(
        address parentIpId,
        address childTokenContract,
        uint256 childTokenId,
        LicenseTerms calldata licenseTerms
    ) external returns (address childIpId);
}
```

---

# üîç **Function Breakdown & Sources**

### 1. `registerIPAssetFull(...)`

* Purpose: Do **everything in one call**:

  * Register NFT as IP Asset
  * Upload IP + NFT metadata
  * Attach license
  * Configure royalties

| Param           | Source           | Notes                            |
| --------------- | ---------------- | -------------------------------- |
| `tokenContract` | Backend/frontend | NFT contract address             |
| `tokenId`       | Backend/frontend | Token minted on ERC-721 contract |
| `ipMetadata`    | Backend/frontend | Upload JSON ‚Üí URI + hash         |
| `licenseTerms`  | Frontend/backend | License config                   |
| `royaltyConfig` | Frontend/backend | Royalty % + receiver             |
| `ipId` (return) | On-chain         | IP Account deployed address      |

---

### 2. `registerIPAssetBasic(...)`

* Purpose: Register IP Asset **without license/royalty**
* Useful if you just want to store metadata first

---

### 3. `attachLicenseAndRoyalty(...)`

* Purpose: Add license + royalty to **existing IP Asset**
* **ipId**: From Registry (`register` call)
* **licenseTerms + royaltyConfig**: Frontend/backend forms

---

### 4. `registerDerivativeIP(...)`

* Purpose: Mint a **derivative IP** of a parent IP
* Calls:

  * LicensingModule to create license for derivative
  * Registry to deploy child IP Account

| Param                | Source           | Notes                          |
| -------------------- | ---------------- | ------------------------------ |
| `parentIpId`         | On-chain         | Parent IP Account              |
| `childTokenContract` | Backend/frontend | Child NFT contract             |
| `childTokenId`       | Backend/frontend | Child token minted             |
| `licenseTerms`       | Frontend/backend | License governing derivative   |
| `childIpId`          | On-chain         | Deployed derivative IP Account |

---

# ‚ö†Ô∏è **Usage Notes**

1. **Frontend friendly:**
   Call these functions via MetaMask / ethers.js instead of interacting with individual modules.

2. **Backend responsibilities:**

   * Upload JSON metadata
   * Hash content
   * Prepare license and royalty structs

3. **On-chain:**

   * Periphery module calls Registry ‚Üí IPAccount ‚Üí LicensingModule ‚Üí RoyaltyModule under the hood
   * Returns the IP Account address for further interactions

4. **Example call in frontend (ethers.js):**

```js
const ipId = await periphery.registerIPAssetFull(
    nftAddress,
    tokenId,
    ipMetadata,
    licenseTerms,
    royaltyConfig
);
```

---

Boss, with **this**, we now have reconstructed all the **core interfaces + WorkflowStructs + periphery helper** in Story Protocol:

1. **IIPAssetRegistry**
2. **IIPAccount**
3. **ILicensingModule**
4. **ILicenseToken**
5. **IRoyaltyModule**
6. **WorkflowStructs**
7. **IStoryPeriphery**
